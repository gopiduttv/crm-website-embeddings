
Design Doc: Scalable CRM Widget Platform

Version: 1.0
Date: October 16, 2025
Status: Proposed

## 1. Overview

This document outlines the architecture for a scalable, high-performance system to embed multiple CRM widgets (Chat, Analytics, Forms, etc.) onto client websites. The design prioritizes client-side performance, ease of integration, and centralized control. It uses the Inline Bootloader (Command Queue) pattern, where a server-generated snippet provides a zero-configuration experience for the end-user.

## 2. Core Architecture

The system consists of three primary components:
Application Server: A backend service that authenticates clients, serves a personalized loader script, and provides configuration data.
CDN (Content Delivery Network): A distributed network that hosts and serves the main, static application file for high performance.
Client-Side Script: The code that runs in the user's browser, composed of a lightweight loader and the main application.

## 3. Component Breakdown


### 3.1. Client-Side Integration Snippet

The client integration is a single, server-generated <script> tag. This is the only piece of code a client ever needs to add to their website.
Client Embed Code (Example for clientId: 'abc-123'):

HTML


<script src="https://api.yourcrm.com/script/abc-123.js" async defer></script>



### 3.2. Application Server (https://www.google.com/search?q=api.yourcrm.com)

The server has two primary responsibilities: generating the loader and providing configuration.
Endpoint 1: Dynamic Script Loader
Route: GET /script/:clientId.js
Purpose: To generate a personalized loader script for each client.
Logic:
Extract clientId from the URL.
Validate the clientId and check the client's active subscription status.
Fetch the client's widget configuration from the database (e.g., which widgets are enabled, color themes, etc.).
Render a JavaScript template, injecting the fetched configuration.
Return the response with a Content-Type: application/javascript header.
Generated Script (abc-123.js) Content:

JavaScript


// This file is dynamically generated by the server
(function() {
  // 1. Create the command queue placeholder
  window.YourCRM = window.YourCRM || function() {
    (window.YourCRM.q = window.YourCRM.q || []).push(arguments);
  };

  // 2. Inject the client's specific configuration
  const clientConfig = {
    clientId: 'abc-123',
    chat: { enabled: true, color: '#3A86FF' },
    analytics: { enabled: true },
    forms: { enabled: false }
  };
  window.YourCRM('init', clientConfig);

  // 3. Load the main application from the CDN
  var js = document.createElement('script');
  js.src = "https://cdn.yourcrm.com/main-app.v1.js";
  js.async = true;
  document.head.appendChild(js);
})();



### 3.3. CDN (https://www.google.com/search?q=cdn.yourcrm.com)

The CDN is responsible for serving the heavy, static assets.
Asset: main-app.v1.js (versioned for cache-busting)
Purpose: Contains the code for all possible widgets and trackers (Chat, Analytics, Forms, etc.). It is generic and identical for all clients.
Benefits: High-speed delivery, global distribution, and reduced load on the application server.

## 4. Main Application (main-app.js) Internal Design


### 4.1. Initialization Flow

Script Load: main-app.js downloads and executes.
Read Queue: It immediately finds window.YourCRM.q.
Process Config: It locates the init command and retrieves the configuration object.
Module Loading: Based on the config (e.g., chat.enabled: true), it initializes the required modules.
API Swap: It replaces the placeholder YourCRM function with the final API object, which has real methods.
Process Backlog: It processes any other commands that were queued before it finished loading.

### 4.2. Modular Structure

The main-app.js will be built with a modular architecture.
Example main-app.js structure:

JavaScript


import ChatWidget from './modules/chat.js';
import Analytics from './modules/analytics.js';
import FormManager from './modules/forms.js';

class MainApplication {
  constructor(config) {
    this.config = config;
    this.loadModules();
  }

  loadModules() {
    if (this.config.chat.enabled) {
      this.chat = new ChatWidget(this.config.chat);
    }
    if (this.config.analytics.enabled) {
      this.analytics = new Analytics(this.config.analytics);
    }
    // ... and so on
  }

  // Public API methods
  api(command, args) {
    const [module, action] = command.split(':');
    if (module === 'chat' && this.chat) {
      this.chat[action](args); // e.g., this.chat.open(args)
    }
  }
}

// Initialization logic to find config and start the app...



## 5. Data Flow Diagram

This diagram shows the end-to-end flow from page load to widget initialization.
Browser: Requests the client's webpage.
Client Server: Returns HTML containing the <script src=".../abc-123.js"> tag.
Browser: Makes a GET request to api.yourcrm.com/script/abc-123.js.
Application Server: Fetches config from the Database and returns the personalized loader script.
Browser: Executes the loader, which creates the queue and injects another <script> tag for main-app.js.
Browser: Makes a GET request to cdn.yourcrm.com/main-app.js.
CDN: Returns the main application file.
Browser: Executes main-app.js, which reads the queue, initializes the required widgets, and displays them on the page.